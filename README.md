
# Tor-Based Auto-Rotating Proxy

A lightweight setup for creating a self-rotating Tor proxy that automatically changes IP addresses. Perfect for web scraping, API testing, and privacy-focused applications.

## Features

*   Local SOCKS5 proxy (127.0.0.1:9050)
*   Automatic IP rotation every 5 seconds (configurable)
*   No code modifications needed - works with any SOCKS5-compatible tool
*   Simple installation and configuration
*   Cross-platform compatibility (Linux/Unix, Termux)

## Requirements

*   Termux (Android) or Linux/Unix system
*   Python 3.x
*   Tor
*   [stem](https://stem.torproject.org/) library

## Quick Setup

Follow these steps to get the auto-rotating proxy running:

1.  **Install dependencies:**
    On Termux or Debian-based Linux:
    ```bash
    pkg update && pkg upgrade
    pkg install -y tor python
    ```
    On other Linux distributions, use your system's package manager (e.g., `apt`, `yum`, `dnf`) to install `tor` and `python3`.

    Install the Python `stem` library:
    ```bash
    pip install stem
    ```
    *(Optional but recommended: Use a Python virtual environment like `venv` for dependency isolation).*

2.  **Create Tor configuration:**
    Create a directory for Tor's configuration if it doesn't exist, and then create/overwrite the `torrc` file to enable the control port and cookie authentication.
    ```bash
    mkdir -p ~/.tor
    cat > ~/.tor/torrc << EOL
    ControlPort 9051          # Listen on port 9051 for control commands
    CookieAuthentication 1    # Use cookie authentication for control port
    DataDirectory ~/.tor      # Specify Tor's data directory
    Log notice file ~/.tor/notices.log # Optional: Log notices to a file
    EOL
    ```
    *Explanation:*
    *   `ControlPort 9051`: This allows the `stem` library script to communicate with the running Tor process to send signals like IP rotation.
    *   `CookieAuthentication 1`: This is a secure way to authenticate control port connections. Tor creates a cookie file (usually in `~/.tor/control_auth_cookie`) which the script will use for authentication. The user running the script needs read access to this file.
    *   `DataDirectory ~/.tor`: Specifies where Tor should store its data, including the authentication cookie.
    *   `Log notice file ~/.tor/notices.log` (Optional): Directs important Tor messages to a log file, useful for troubleshooting.

3.  **Start Tor service:**
    Start the Tor daemon using the custom configuration.
    ```bash
    tor -f ~/.tor/torrc
    ```
    *Note:* This command will typically run Tor in the foreground, blocking your terminal. For persistent use or to free up your terminal, you should run it in the background (e.g., `tor -f ~/.tor/torrc &`) or manage it as a system service (e.g., using `termux-service start tor` on Termux or `systemctl start tor@default` on Linux if configured). Ensure Tor is running before proceeding.

4.  **Create IP rotation script:**
    Save the following Python code as `rotate_ip.py`. This script connects to Tor's control port and signals it to switch to a new circuit (and thus a new exit IP) periodically.
    ```python3
    import time
    import random
    import requests
    from stem import Signal
    from stem.control import Controller

    def rotate_ip():
        """Signal Tor to switch to a new circuit (rotate IP)."""
        try:
            # Connect to the Tor control port using cookie authentication
            # Assumes the cookie is in the default location relative to DataDirectory
            with Controller.from_port(port=9051) as controller:
                # Authenticate using the cookie generated by Tor
                # (requires the script user to have read access to ~/.tor/control_auth_cookie)
                controller.authenticate()
                controller.signal(Signal.NEWNYM)
                print("[*] IP rotation successful")
        except Exception as e:
            print(f"[!] Error rotating IP: {e}")
            # If authentication fails or Tor is not running, this will fail.
            # Ensure Tor is running and the script has necessary permissions.
            # Consider adding more specific exception handling for stem errors

    def get_current_ip():
        proxies = {
            'http': 'socks5h://127.0.0.1:9050',
            'https': 'socks5h://127.0.0.1:9050'
        }
        try:
            # Add some common headers to look less like a bot
            headers = {
                'User-Agent': random.choice([
                    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/537.36",
                    "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.1 Safari/605.1.15",
                    "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/537.36",
                    "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/108.0"
                ]),
                'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,açå*/*;q=0.8',
                'Accept-Language': 'en-US,en;q=0.5',
                'Connection': 'keep-alive',
                'Upgrade-Insecure-Requests': '1',
                'Cache-Control': 'max-age=0'
            }
            # Use a service that simply returns the IP
            ip = requests.get('https://api.ipify.org', proxies=proxies, headers=headers, timeout=15).text
            print(f"[*] New IP: {ip}")
        except requests.exceptions.RequestException as e:
            print(f"[!] Failed to get current IP via proxy: {e}")
        except Exception as e:
            print(f"[!] Unexpected error getting IP: {e}")

    def main():
        """Main loop to periodically rotate the IP."""
        print("[*] Starting IP rotation service")
        rotation_interval = 5 # seconds, configure here
        print(f"[*] Rotating IP every {rotation_interval} seconds...")

        # Initial IP check before the first rotation cycle starts
        print("[*] Checking initial IP...")
        get_current_ip()


        while True:
            try:
                # Wait for the specified interval before the next rotation
                print(f"[*] Waiting {rotation_interval} seconds for next rotation...")
                time.sleep(rotation_interval)

                rotate_ip()
                # Add a small delay after rotation before checking IP,
                # allowing Tor to establish the new circuit
                time.sleep(2) # Give Tor a moment to establish a new circuit
                get_current_ip()

            except KeyboardInterrupt:
                print("\n[*] Stopping IP rotation service requested by user.")
                break # Exit the loop on Ctrl+C
            except Exception as e:
                print(f"[!] Unexpected error in main loop: {e}")
                # Wait longer before retrying in case of unexpected errors
                time.sleep(10)

    if __name__ == "__main__":
        # Give Tor a moment to start and create the cookie file if just started
        # This delay might need adjustment based on your system speed and Tor's startup time
        print("[*] Waiting for Tor to start...")
        time.sleep(5) # Wait a bit longer initially for Tor and cookie file

        # Verify cookie file exists before attempting connection
        import os
        cookie_path = os.path.expanduser("~/.tor/control_auth_cookie")
        if not os.path.exists(cookie_path):
             print(f"[!] Authentication cookie not found at {cookie_path}. Ensure Tor is running with CookieAuthentication 1 and DataDirectory set.")
             print("[!] Aborting script.")
        else:
            print(f"[*] Found cookie file: {cookie_path}")
            main()

    ```
    Run the script:
    ```bash
    python rotate_ip.py
    ```
    *Note:* Like the Tor command, this script runs in the foreground. You might want to run it in the background using `python rotate_ip.py &` or in a separate terminal/session. Both the `tor` process and `rotate_ip.py` script must be running for the setup to work. The script includes checks for the cookie file and initial Tor startup delay.

## Usage

Once Tor is running and listening on `127.0.0.1:9050` (this is the default SOCKS port even without specific `torrc` lines, but requires the ControlPort for rotation), and the `rotate_ip.py` script is running, you can configure your applications to use the proxy.

### Proxy Configuration

*   **Host:** `127.0.0.1`
*   **Port:** `9050`
*   **Type:** `SOCKS5` (or `SOCKS5h` for DNS resolution via proxy)

### Example Implementations

#### cURL
Use the `--socks5` flag to specify the SOCKS5 proxy.
```bash
curl --socks5 127.0.0.1:9050 https://api.ipify.org
```

#### Python Requests
Use the `proxies` dictionary. It's highly recommended to use `socks5h://` instead of `socks5://` to ensure that DNS lookups are also routed through Tor, preventing potential DNS leaks. You'll also need to install `requests[socks]` (`pip install requests[socks]`).
```python3
import requests

# Ensure you have installed: pip install requests[socks]
proxies = {
    'http': 'socks5h://127.0.0.1:9050',
    'https': 'socks5h://127.0.0.1:9050'
}

# Add common headers to look less like a bot
headers = {
    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/537.36', # Example User-Agent
    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,açå*/*;q=0.8',
    'Accept-Language': 'en-US,en;q=0.5',
    'Connection': 'keep-alive',
    'Upgrade-Insecure-Requests': '1',
    'Cache-Control': 'max-age=0'
}

try:
    response = requests.get('https://api.ipify.org', proxies=proxies, headers=headers, timeout=15)
    response.raise_for_status() # Raise an HTTPError for bad responses (4xx or 5xx)
    print(response.text)
except requests.exceptions.RequestException as e:
    print(f"Request failed: {e}")

```

#### Browser/Automation Tools
Configuration varies greatly between tools and libraries (like Selenium, Playwright, Puppeteer). Here's an example structure; consult your tool's documentation. Again, prefer `socks5h` if supported to prevent DNS leaks.
```python3
# Example for a library/tool config structure (not direct Python requests)
# This is illustrative. Actual implementation depends on the specific library.
proxy_settings = {
    'proxy': {
        'http': 'socks5://127.0.0.0:9050', # Use socks5h:// if possible
        'https': 'socks5://127.0.0.0:9050' # Use socks5h:// if possible
    }
}
# Example for Playwright (Python) - configuration usually per context or browser launch
# from playwright.sync_api import sync_playwright
# with sync_playwright() as p:
#     browser = p.chromium.launch(proxy={"server": "socks5://127.0.0.1:9050"})
#     page = browser.new_page()
#     page.goto("https://api.ipify.org")
#     print(page.text_content("body"))
#     browser.close()
```
*Note:* Using browser automation with Tor can be complex due to fingerprinting issues. Tor Browser has specific hardening to prevent this; standard browsers don't.

## Best Practices

1.  **Implement error handling:** Your application should gracefully handle connection errors, timeouts, and potential blocks when using the proxy.
2.  **Add reasonable delays:** Avoid making requests too quickly after an IP rotation or between successive requests to the same target. This reduces the chance of being blocked. Respect target website's `robots.txt`.
3.  **Use appropriate headers:** Send realistic `User-Agent` and other common headers (like `Accept`, `Accept-Language`). Avoid identifying yourself as a bot.
4.  **Monitor Tor circuit stability:** The rotation script prints status messages. Check your Tor logs (`~/.tor/tor/notices.log` or similar) if you encounter issues.
5.  **Handle captchas:** Some sites may present captchas when they detect suspicious traffic patterns, even from different IPs. Your application should be prepared for this.
6.  **Use HTTPS:** Always use HTTPS to encrypt traffic between the Tor exit node and the destination server.

## Advanced Configuration

### Custom Rotation Interval
Modify the `rotation_interval` variable in the `rotate_ip.py` script to change the rotation frequency. Shorter intervals might put more strain on the Tor network and yourself; longer intervals might be less effective against aggressive blocking. Consider that finding a new circuit takes time.
```python3
rotation_interval = 10  # Change to 10 seconds or any desired value
```

### Exit Node Control
You can influence which countries or specific nodes Tor uses as the exit point. Add these lines to your `~/.tor/torrc` file. Consult the Tor manual for more options (`man tor`).
```bash
# Example: Only exit through US, UK, or Germany nodes
ExitNodes {us},{gb},{de}
# Ensure only nodes from the ExitNodes list are used
StrictNodes 1
# Avoid previously failed exit nodes for a while (default 60 min)
ExcludeExitNodes {bad}, {previously_failed}
```
*Note:* Restricting exit nodes can reduce anonymity and might make it harder to find available circuits, potentially impacting performance and rotation success. Aggressive restrictions can sometimes make it impossible to find a circuit.

## Troubleshooting

1.  **Check Tor service status:** Ensure the Tor daemon is running.
    ```bash
    ps aux | grep tor
    ```
    or check system service status if applicable (e.g., `systemctl status tor` or `termux-service status tor`).
2.  **Check `rotate_ip.py` script status:** Ensure the Python script is running and not throwing errors.
    ```bash
    ps aux | grep rotate_ip.py
    ```
    Check the output of the script for error messages. Look for errors connecting to the ControlPort or with authentication.
3.  **Verify proxy connectivity:** Use `curl` to check if the SOCKS proxy is working by visiting a Tor detection site.
    ```bash
    curl --socks5 127.0.0.1:9050 https://check.torproject.org
    ```
    It should indicate that you are using Tor. If not, check if Tor is running and listening on port 9050 (default).
4.  **Monitor IP rotation:** Use `watch` to repeatedly check your perceived IP address via the proxy and see if it changes over time.
    ```bash
    watch -n 5 'curl --socks5 127.0.0.1:9050 https://api.ipify.org || echo "Proxy error or no response"'
    ```
    Replace `5` with the rotation interval you set (or just keep 5 for checking frequency). The IP should change every rotation interval (plus the small script delay).
5.  **Check cookie file access:** Ensure the user running `rotate_ip.py` has read permissions for `~/.tor/control_auth_cookie`. The script specifically checks for this now.
6.  **Check Tor logs:** Examine the Tor logs (e.g., `~/.tor/notices.log`) for errors related to starting the control port, creating the cookie file, or building circuits.

## Limitations

*   **Website Blocking:** Many large websites actively block known Tor exit nodes.
*   **Performance:** Tor network performance can vary greatly and is generally slower than a direct connection. It is not suitable for high-bandwidth tasks like streaming.
*   **Rotation Speed:** While the script signals a new IP every N seconds, finding a new circuit with a different exit node might take slightly longer or occasionally fail if the network is congested or exit nodes are scarce for your criteria (e.g., `ExitNodes` restriction).
*   **Bandwidth:** Tor is not designed for high-bandwidth applications like streaming or large file downloads.
*   **Anonymity vs. Speed:** Faster rotation might not always be more anonymous or effective if it leads to circuit failures or draws suspicion. Frequent requests without delays or proper headers are also risky.

## Security Considerations

*   **Tor vs. VPN:** Tor provides anonymity by routing traffic through multiple relays, but it does not encrypt traffic between your application and the SOCKS proxy (`127.0.0.1`). Use HTTPS for sensitive data.
*   **End-to-End Encryption:** Tor encrypts traffic between relays, but the exit node decrypts the traffic before sending it to the destination server if it's unencrypted (HTTP). Always use HTTPS for secure communication to ensure encryption from your application all the way to the destination server.
*   **DNS Leaks:** Using a standard SOCKS5 proxy (`socks5://`) might cause DNS requests to be resolved locally before being sent through Tor, potentially leaking information. Use `socks5h://` where supported (like in Python Requests) to delegate DNS resolution to the Tor proxy, preventing this leak.
*   **Traffic Correlation:** While Tor makes it difficult, sophisticated adversaries might still be able to correlate your traffic patterns over time, especially with aggressive, predictable rotation and usage patterns or if your application has unique fingerprintable characteristics.
*   **Authentication:** The setup uses cookie authentication for the Tor control port, which is the recommended method. Ensure the `~/.tor` directory and the cookie file have appropriate permissions (`chmod 700 ~/.tor`, `chmod 600 ~/.tor/control_auth_cookie` if needed, though Tor usually sets this correctly) to prevent unauthorized access to the control port.

## License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details (or simply state it as done below if you don't have a separate file).

## Contributing

Pull requests are welcome. For major changes, please open an issue first to discuss what you would like to change.

## Disclaimer

Use this setup responsibly and in accordance with all applicable laws, terms of service, and ethical guidelines. The creators and contributors are not responsible for any misuse of this setup.
